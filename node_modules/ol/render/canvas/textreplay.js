import _ol_ from '../../index.js';
import _ol_colorlike_ from '../../colorlike.js';
import _ol_dom_ from '../../dom.js';
import _ol_geom_flat_straightchunk_ from '../../geom/flat/straightchunk.js';
import _ol_geom_GeometryType_ from '../../geom/geometrytype.js';
import _ol_has_ from '../../has.js';
import _ol_render_canvas_ from '../canvas.js';
import _ol_render_canvas_Instruction_ from '../canvas/instruction.js';
import _ol_render_canvas_Replay_ from '../canvas/replay.js';
import _ol_render_replay_ from '../replay.js';
import _ol_structs_LRUCache_ from '../../structs/lrucache.js';
import _ol_style_TextPlacement_ from '../../style/textplacement.js';

/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @struct
 */
var _ol_render_canvas_TextReplay_ = function(tolerance, maxExtent, resolution, pixelRatio, overlaps) {

  _ol_render_canvas_Replay_.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps);

  /**
   * @private
   * @type {Array.<HTMLCanvasElement>}
   */
  this.labels_ = null;

  /**
   * @private
   * @type {string}
   */
  this.text_ = '';

  /**
   * @private
   * @type {number}
   */
  this.textOffsetX_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.textOffsetY_ = 0;

  /**
   * @private
   * @type {boolean|undefined}
   */
  this.textRotateWithView_ = undefined;

  /**
   * @private
   * @type {number}
   */
  this.textRotation_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.textScale_ = 0;

  /**
   * @private
   * @type {?ol.CanvasFillState}
   */
  this.textFillState_ = null;

  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */
  this.textStrokeState_ = null;

  /**
   * @private
   * @type {?ol.CanvasTextState}
   */
  this.textState_ = null;

  /**
   * @private
   * @type {string}
   */
  this.textKey_ = '';

  /**
   * @private
   * @type {string}
   */
  this.fillKey_ = '';

  /**
   * @private
   * @type {string}
   */
  this.strokeKey_ = '';

  while (_ol_render_canvas_TextReplay_.labelCache_.canExpireCache()) {
    _ol_render_canvas_TextReplay_.labelCache_.pop();
  }

};

_ol_.inherits(_ol_render_canvas_TextReplay_, _ol_render_canvas_Replay_);


/**
 * @private
 * @type {ol.structs.LRUCache.<HTMLCanvasElement>}
 */
_ol_render_canvas_TextReplay_.labelCache_ = new _ol_structs_LRUCache_();


/**
 * @param {string} font Font to use for measuring.
 * @return {ol.Size} Measurement.
 */
_ol_render_canvas_TextReplay_.measureTextHeight = (function() {
  var textContainer;
  return function(font, lines, widths) {
    if (!textContainer) {
      textContainer = document.createElement('span');
      textContainer.textContent = 'M';
      textContainer.style.visibility = 'hidden';
      textContainer.style.whiteSpace = 'nowrap';
    }
    textContainer.style.font = font;
    document.body.appendChild(textContainer);
    var height = textContainer.offsetHeight;
    document.body.removeChild(textContainer);
    return height;
  };
})();


/**
 * @this {Object}
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} pixelRatio Pixel ratio.
 * @param {string} text Text.
 * @return {number} Width.
 */
_ol_render_canvas_TextReplay_.getTextWidth = function(context, pixelRatio, text) {
  var width = this[text];
  if (!width) {
    this[text] = width = context.measureText(text).width;
  }
  return width * pixelRatio;
};


/**
 * @param {string} font Font to use for measuring.
 * @param {Array.<string>} lines Lines to measure.
 * @param {Array.<number>} widths Array will be populated with the widths of
 * each line.
 * @return {number} Width of the whole text.
 */
_ol_render_canvas_TextReplay_.measureTextWidths = (function() {
  var context;
  return function(font, lines, widths) {
    if (!context) {
      context = _ol_dom_.createCanvasContext2D(1, 1);
    }
    context.font = font;
    var numLines = lines.length;
    var width = 0;
    var currentWidth, i;
    for (i = 0; i < numLines; ++i) {
      currentWidth = context.measureText(lines[i]).width;
      width = Math.max(width, currentWidth);
      widths.push(currentWidth);
    }
    return width;
  };
})();


/**
 * @inheritDoc
 */
_ol_render_canvas_TextReplay_.prototype.drawText = function(geometry, feature) {
  var fillState = this.textFillState_;
  var strokeState = this.textStrokeState_;
  var textState = this.textState_;
  if (this.text_ === '' || !textState || (!fillState && !strokeState)) {
    return;
  }

  var begin = this.coordinates.length;

  var geometryType = geometry.getType();
  var flatCoordinates = null;
  var end = 2;
  var stride = 2;
  var i, ii;

  if (this.textState_.placement === _ol_style_TextPlacement_.LINE) {
    var ends;
    flatCoordinates = geometry.getFlatCoordinates();
    stride = geometry.getStride();
    if (geometryType == _ol_geom_GeometryType_.LINE_STRING) {
      ends = [flatCoordinates.length];
    } else if (geometryType == _ol_geom_GeometryType_.MULTI_LINE_STRING) {
      ends = geometry.getEnds();
    } else if (geometryType == _ol_geom_GeometryType_.POLYGON) {
      ends = geometry.getEnds().slice(0, 1);
    } else if (geometryType == _ol_geom_GeometryType_.MULTI_POLYGON) {
      var endss = geometry.getEndss();
      ends = [];
      for (i = 0, ii = endss.length; i < ii; ++i) {
        ends.push(endss[i][0]);
      }
    }
    this.beginGeometry(geometry, feature);
    var textAlign = textState.textAlign;
    var flatOffset = 0;
    var flatEnd;
    for (var o = 0, oo = ends.length; o < oo; ++o) {
      if (textAlign == undefined) {
        var range = _ol_geom_flat_straightchunk_.lineString(
            textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
        flatOffset = range[0];
        flatEnd = range[1];
      } else {
        flatEnd = ends[o];
      }
      end = this.appendFlatCoordinates(flatCoordinates, flatOffset, flatEnd, stride, false, false);
      flatOffset = ends[o];
      this.drawChars_(begin, end);
      begin = end;
    }
    this.endGeometry(geometry, feature);

  } else {
    var label = this.getImage_(this.text_, !!this.textFillState_, !!this.textStrokeState_);
    var width = label.width / this.pixelRatio;
    switch (geometryType) {
      case _ol_geom_GeometryType_.POINT:
      case _ol_geom_GeometryType_.MULTI_POINT:
        flatCoordinates = geometry.getFlatCoordinates();
        end = flatCoordinates.length;
        break;
      case _ol_geom_GeometryType_.LINE_STRING:
        flatCoordinates = /** @type {ol.geom.LineString} */ (geometry).getFlatMidpoint();
        break;
      case _ol_geom_GeometryType_.CIRCLE:
        flatCoordinates = /** @type {ol.geom.Circle} */ (geometry).getCenter();
        break;
      case _ol_geom_GeometryType_.MULTI_LINE_STRING:
        flatCoordinates = /** @type {ol.geom.MultiLineString} */ (geometry).getFlatMidpoints();
        end = flatCoordinates.length;
        break;
      case _ol_geom_GeometryType_.POLYGON:
        flatCoordinates = /** @type {ol.geom.Polygon} */ (geometry).getFlatInteriorPoint();
        if (!textState.exceedLength && flatCoordinates[2] / this.resolution < width) {
          return;
        }
        stride = 3;
        break;
      case _ol_geom_GeometryType_.MULTI_POLYGON:
        var interiorPoints = /** @type {ol.geom.MultiPolygon} */ (geometry).getFlatInteriorPoints();
        flatCoordinates = [];
        for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {
          if (textState.exceedLength || interiorPoints[i + 2] / this.resolution >= width) {
            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
          }
        }
        end = flatCoordinates.length;
        if (end == 0) {
          return;
        }
        break;
      default:
    }
    end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);
    this.beginGeometry(geometry, feature);
    this.drawTextImage_(label, begin, end);
    this.endGeometry(geometry, feature);
  }
};


/**
 * @private
 * @param {string} text Text.
 * @param {boolean} fill Fill.
 * @param {boolean} stroke Stroke.
 * @return {HTMLCanvasElement} Image.
 */
_ol_render_canvas_TextReplay_.prototype.getImage_ = function(text, fill, stroke) {
  var label;
  var key = (stroke ? this.strokeKey_ : '') + this.textKey_ + text + (fill ? this.fillKey_ : '');

  var lines = text.split('\n');
  var numLines = lines.length;
  if (!_ol_render_canvas_TextReplay_.labelCache_.containsKey(key)) {
    var strokeState = this.textStrokeState_;
    var fillState = this.textFillState_;
    var textState = this.textState_;
    var pixelRatio = this.pixelRatio;
    var scale = this.textScale_ * pixelRatio;
    var align =  _ol_render_replay_.TEXT_ALIGN[textState.textAlign || _ol_render_canvas_.defaultTextAlign];
    var strokeWidth = stroke && strokeState.lineWidth ? strokeState.lineWidth : 0;

    var widths = [];
    var width = _ol_render_canvas_TextReplay_.measureTextWidths(textState.font, lines, widths);
    var lineHeight = _ol_render_canvas_TextReplay_.measureTextHeight(textState.font);
    var height = lineHeight * numLines;
    var renderWidth = (width + strokeWidth);
    var context = _ol_dom_.createCanvasContext2D(
        Math.ceil(renderWidth * scale),
        Math.ceil((height + strokeWidth) * scale));
    label = context.canvas;
    _ol_render_canvas_TextReplay_.labelCache_.set(key, label);
    context.scale(scale, scale);
    context.font = textState.font;
    if (stroke) {
      context.strokeStyle = strokeState.strokeStyle;
      context.lineWidth = strokeWidth * (_ol_has_.SAFARI ? scale : 1);
      context.lineCap = strokeState.lineCap;
      context.lineJoin = strokeState.lineJoin;
      context.miterLimit = strokeState.miterLimit;
      if (_ol_has_.CANVAS_LINE_DASH) {
        context.setLineDash(strokeState.lineDash);
        context.lineDashOffset = strokeState.lineDashOffset;
      }
    }
    if (fill) {
      context.fillStyle = fillState.fillStyle;
    }
    context.textBaseline = 'top';
    context.textAlign = 'center';
    var leftRight = (0.5 - align);
    var x = align * label.width / scale + leftRight * strokeWidth;
    var i;
    if (stroke) {
      for (i = 0; i < numLines; ++i) {
        context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * strokeWidth + i * lineHeight);
      }
    }
    if (fill) {
      for (i = 0; i < numLines; ++i) {
        context.fillText(lines[i], x + leftRight * widths[i], 0.5 * strokeWidth + i * lineHeight);
      }
    }
  }
  return _ol_render_canvas_TextReplay_.labelCache_.get(key);
};


/**
 * @private
 * @param {HTMLCanvasElement} label Label.
 * @param {number} begin Begin.
 * @param {number} end End.
 */
_ol_render_canvas_TextReplay_.prototype.drawTextImage_ = function(label, begin, end) {
  var textState = this.textState_;
  var strokeState = this.textStrokeState_;
  var pixelRatio = this.pixelRatio;
  var align = _ol_render_replay_.TEXT_ALIGN[textState.textAlign || _ol_render_canvas_.defaultTextAlign];
  var baseline = _ol_render_replay_.TEXT_ALIGN[textState.textBaseline];
  var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;

  var anchorX = align * label.width / pixelRatio + 2 * (0.5 - align) * strokeWidth;
  var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
  this.instructions.push([_ol_render_canvas_Instruction_.DRAW_IMAGE, begin, end,
    label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,
    label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,
    1, true, label.width
  ]);
  this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.DRAW_IMAGE, begin, end,
    label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,
    label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,
    1 / pixelRatio, true, label.width
  ]);
};


/**
 * @private
 * @param {number} begin Begin.
 * @param {number} end End.
 */
_ol_render_canvas_TextReplay_.prototype.drawChars_ = function(begin, end) {
  var pixelRatio = this.pixelRatio;
  var strokeState = this.textStrokeState_;
  var fill = !!this.textFillState_;
  var stroke = !!strokeState;
  var textState = this.textState_;
  var baseline = _ol_render_replay_.TEXT_ALIGN[textState.textBaseline];

  var labels = [];
  var text = this.text_;
  var numChars = this.text_.length;
  var i;

  if (stroke) {
    for (i = 0; i < numChars; ++i) {
      labels.push(this.getImage_(text.charAt(i), false, stroke));
    }
  }
  if (fill) {
    for (i = 0; i < numChars; ++i) {
      labels.push(this.getImage_(text.charAt(i), fill, false));
    }
  }

  var context = labels[0].getContext('2d');
  var offsetY = this.textOffsetY_ * pixelRatio;
  var align = _ol_render_replay_.TEXT_ALIGN[textState.textAlign || _ol_render_canvas_.defaultTextAlign];
  var widths = {};
  this.instructions.push([_ol_render_canvas_Instruction_.DRAW_CHARS,
    begin, end, labels, baseline,
    textState.exceedLength, textState.maxAngle,
    _ol_render_canvas_TextReplay_.getTextWidth.bind(widths, context, pixelRatio * this.textScale_),
    offsetY, this.text_, align, 1
  ]);
  this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.DRAW_CHARS,
    begin, end, labels, baseline,
    textState.exceedLength, textState.maxAngle,
    _ol_render_canvas_TextReplay_.getTextWidth.bind(widths, context, this.textScale_),
    offsetY, this.text_, align, 1 / pixelRatio
  ]);
};


/**
 * @inheritDoc
 */
_ol_render_canvas_TextReplay_.prototype.setTextStyle = function(textStyle) {
  var textState, fillState, strokeState;
  if (!textStyle) {
    this.text_ = '';
  } else {
    var textFillStyle = textStyle.getFill();
    if (!textFillStyle) {
      fillState = this.textFillState_ = null;
    } else {
      var textFillStyleColor = textFillStyle.getColor();
      var fillStyle = _ol_colorlike_.asColorLike(textFillStyleColor ?
        textFillStyleColor : _ol_render_canvas_.defaultFillStyle);
      fillState = this.textFillState_;
      if (!fillState) {
        fillState = this.textFillState_ = /** @type {ol.CanvasFillState} */ ({});
      }
      fillState.fillStyle = fillStyle;
    }
    var textStrokeStyle = textStyle.getStroke();
    if (!textStrokeStyle) {
      strokeState = this.textStrokeState_ = null;
    } else {
      var textStrokeStyleColor = textStrokeStyle.getColor();
      var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
      var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
      var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
      var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
      var textStrokeStyleWidth = textStrokeStyle.getWidth();
      var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
      var lineCap = textStrokeStyleLineCap !== undefined ?
        textStrokeStyleLineCap : _ol_render_canvas_.defaultLineCap;
      var lineDash = textStrokeStyleLineDash ?
        textStrokeStyleLineDash.slice() : _ol_render_canvas_.defaultLineDash;
      var lineDashOffset = textStrokeStyleLineDashOffset !== undefined ?
        textStrokeStyleLineDashOffset : _ol_render_canvas_.defaultLineDashOffset;
      var lineJoin = textStrokeStyleLineJoin !== undefined ?
        textStrokeStyleLineJoin : _ol_render_canvas_.defaultLineJoin;
      var lineWidth = textStrokeStyleWidth !== undefined ?
        textStrokeStyleWidth : _ol_render_canvas_.defaultLineWidth;
      var miterLimit = textStrokeStyleMiterLimit !== undefined ?
        textStrokeStyleMiterLimit : _ol_render_canvas_.defaultMiterLimit;
      var strokeStyle = _ol_colorlike_.asColorLike(textStrokeStyleColor ?
        textStrokeStyleColor : _ol_render_canvas_.defaultStrokeStyle);
      strokeState = this.textStrokeState_;
      if (!strokeState) {
        strokeState = this.textStrokeState_ = /** @type {ol.CanvasStrokeState} */ ({});
      }
      strokeState.lineCap = lineCap;
      strokeState.lineDash = lineDash;
      strokeState.lineDashOffset = lineDashOffset;
      strokeState.lineJoin = lineJoin;
      strokeState.lineWidth = lineWidth;
      strokeState.miterLimit = miterLimit;
      strokeState.strokeStyle = strokeStyle;
    }
    var textFont = textStyle.getFont();
    var textOffsetX = textStyle.getOffsetX();
    var textOffsetY = textStyle.getOffsetY();
    var textRotateWithView = textStyle.getRotateWithView();
    var textRotation = textStyle.getRotation();
    var textScale = textStyle.getScale();
    var textText = textStyle.getText();
    var textTextAlign = textStyle.getTextAlign();
    var textTextBaseline = textStyle.getTextBaseline();
    var font = textFont !== undefined ?
      textFont : _ol_render_canvas_.defaultFont;
    var textAlign = textTextAlign;
    var textBaseline = textTextBaseline !== undefined ?
      textTextBaseline : _ol_render_canvas_.defaultTextBaseline;
    textState = this.textState_;
    if (!textState) {
      textState = this.textState_ = /** @type {ol.CanvasTextState} */ ({});
    }
    textState.exceedLength = textStyle.getExceedLength();
    textState.font = font;
    textState.maxAngle = textStyle.getMaxAngle();
    textState.placement = textStyle.getPlacement();
    textState.textAlign = textAlign;
    textState.textBaseline = textBaseline;

    this.text_ = textText !== undefined ? textText : '';
    this.textOffsetX_ = textOffsetX !== undefined ? textOffsetX : 0;
    this.textOffsetY_ = textOffsetY !== undefined ? textOffsetY : 0;
    this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
    this.textRotation_ = textRotation !== undefined ? textRotation : 0;
    this.textScale_ = textScale !== undefined ? textScale : 1;

    this.strokeKey_ = strokeState ?
      (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : _ol_.getUid(strokeState.strokeStyle)) +
      strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth +
      strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' :
      '';
    this.textKey_ = textState.font + (textState.textAlign || '?') + this.textScale_;
    this.fillKey_ = fillState ?
      (typeof fillState.fillStyle == 'string' ? fillState.fillStyle : ('|' + _ol_.getUid(fillState.fillStyle))) :
      '';
  }
};
export default _ol_render_canvas_TextReplay_;
